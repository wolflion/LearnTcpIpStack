## 缘起

+ 目前是想分为3个阶段，各阶段暂定1个月（整理）吧，因为之前有零星看过了：
  + 阶段1是**网卡驱动**，
  + 阶段2是**L3层相关**，
  + 阶段3是**socket层和L4**
+ 这部分是来自《深入理解linux网络技术内幕》的Part5-7，也就是从chap14-chap36
+ 目标是**2024-09**把这部分啃完吧，**建立了知识骨架**，代码实现细节先不求（**主要是知识点多**）
  + chap1-13，**相关的函数细节**要把代码注释一下
+ 自己整理的[链接](https://gitee.com/fewolflion/BookNote/blob/master/00tech_output_ppt/20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%A7%E7%B1%BB/11tcp-ip-stack%E5%86%85%E6%A0%B8/02%E4%B8%89%E5%B1%82%E5%8D%8F%E8%AE%AE-%E6%A1%A5%E6%8E%A5%20%E8%B7%AF%E7%94%B1%20%E9%82%BB%E5%B1%85%20IP.pdf)是这个
  + 用ppt写的，转成的pdf
  + md写的吧，*自己搞图和标色，不太方便*

## 内容

+ outline呢，*差不多，想用自己了解到的给串一下*
+ 简单的说，**IPv4的大蓝图**用到了**路由缓存dst**，（寻路），**邻居子系统**（L3到L2地址转换），**网桥**（*这个不绝对，发给网桥设备，还是真实的网卡设备，L3应该不用感知*）

### 0、outline

+ **每一层都有一个核心问题**，这一层的功能是啥？有什么用？

#### part4、桥接

+ 一、输入，`netif_receive_skb()`，**怎么区分，真实网卡设备，和虚拟设备**【真实设备的就是drivers下面的网卡驱动，虚拟设备，就是net/bridge下面的】*不完全绝对啊*
+ 二、输出，跟**e100.c一样都要调用`dev_queue_xmit()`输出一样**，真正绑定的实例还是**`net_device_ops`实例**中的`ndo_xmit`对应的真实函数，*这有点类似于虚拟函数*
+ 三、**中间处理逻辑**，核心是**大蓝图**，以及逻辑基本都在`net/bridge`目录
+ 【新的问题：**桥接**在整个协议栈的位置】
  + *具体不记得了，应该也是有个大蓝图的*
+ 怎么在用户态创建网桥，用什么命令？

#### part5、IPv4

+ **记住图18-1，对应的大蓝图**

+ 一、输出，先记一个吧，**`ip_queue_xmit()`**，还有`ip_push_pending_frames()`，中间会经过**`dst->output()`**，*省略一些细节*，到达`dev_queue_xmit()`
+ 二、输入，网卡驱动对应的**协议处理函数`ip_rcv()`**，还是通过`dst->input()`进行**转发`ip_forward()`**和**传输到L4层，`ip_local_deliver()`**
+ 三、中间处理，*目前知道的，就是*，（**分段和重组**），至少*找路由，找网络邻居*细节先不管

#### part6、邻居子系统

+ 这部分逻辑比较简单，**就是封装了邻居这层**（之前是ARP和ND），*现在为了弱化ipv4和ipv6的差异*
+ **L3协议与邻居协议间的通用接口**，就是`neigh->ops`

#### part7、路由

+ *不是完全明白*，现在**路由hash**代码中跟书上都不太一样了
+ 目前主要看的是**路由缓存**章节，正好是`dst->input()`这样的
+ 搞清楚了自己的疑问
  + 看路由的时候，想到的是**路由协议**，之前想的是rip，ospf这些对应的rfc文档在**内核中的实现**，后面觉得不对，**它们是用`ip route`这样的命令去配置的**，然后才知道有**路由守护进程**专门干这事

### 一、桥接（）

+ *自己想的*
  + 主线是`net/bridge`，但**核心是2个点（收和发）**，发还是`dev_queue_xmit`但具体是哪个设备就看`ops`的实例了，**收**呢，就是`netif_receive_skb`，真实设备那就是类似于`e100.c`里调用，虚拟设备可能是`tap.c`或者`net/bridge中的br_相关的`，搜了一下是`br_input.c`中的`br_netif_receive_skb()`
  + 另一个线是，想到了`openvswtich`，*他们是不是有共通之处*，粗看了一下，**主要是根据端口**

### 二、IPv4（）

+ 核心还是书中的**大蓝图**
+ 根据rfc791的描述，2个功能（**路由、分包**）再加上传统的**收&发**

#### 2.1、af_inet.c中的初始化涉及到协议栈相关的结构体

+ 流程就是`inet_init()`中的line1950-2004，核心分4步（*代码是ok了，描述还需要润色*）
  + 1、协议的注册，tcp_prot【tcp_ipv4.c中】，
  + 2、注册协议族（屏蔽差异）【af_inet.c中】
  + 3、添加基础协议，【af_inet.c中】
  + 4、加到链表和数组上去 【af_inet.c中】
+ *这部分在 樊东东的chap10有说*，我后面再把这代码注释传到github上

#### 2.2、ip头

+ *这个没什么说的*，参考rfc791

#### 2.3、ip_options（这个在ip头中）

+ *也相对比较独立*，都在ip_options.c中实现了

#### 2.4、收&发

##### 2.4.1、ip_rcv

+ **这个在driver驱动里提过**，它最终会调用`dst_input()`去实现`ip_local_deliver()`还是`ip_forward()`，**发包不存在超过MTU的场景**

##### 2.4.2、发呢，要分协议，ip_queue_xmit只是一个渠道

+ 但最终都一样要走到dst.h中的`dst_output()`，最终到`ip_finish_ouput()`，发包会存在**大于MTU的场景**，分为2部分
  + `ip_fragment()`中进行分片
  + 不需要分片，则直接输出`ip_finish_output2()`输出

#### 2.5、分包与组装

##### 2.5.1、分片（ip_output.c）

+ **入口函数是`ip_fragment()`**，判断依据就是是否大于MTU（*不同的设备有不同的MTU*）
+ 有个问题是*怎么分*？这个在rfc791有个sample，如果不太明白，*[小菜学网络里的-分片](https://fasionchan.com/network/ip/fragmentation/)*  应该是说明白了，怎么计算的了

##### 2.5.2、组装（ip_fragement.c）

+ 核心还是`ipq`结构体，背后的思想是`rhashtable【可扩展大小的哈希表】`
+ **入口函数是`ip_defrag()`**

#### tmp

+ 2024-09-13，1个cubi有点赶，要去看电影，就先这么着

### 三、邻居子系统

+ 自己想的
  + 这个倒不难，本质就是把arp.c和nd*.c给抽象了一个neighbour.c/h的功能
  + 这个子系统的功能是**L3到L2的转换**

### 四、路由

+ tmp
  + *这部分没怎么看*，就是在看ipv4时看到`dst.h`中的`dst_input()`这样的实现

## 最后

### 履历

+ 0.1版，2024-09月第1周整理的，目前已经把这4个部分过了一遍了，**Part7路由中的一些，实现的基础知识**有点欠缺，*暂未找到合适的材料*，2024-09-05，用了一个cubi