## 缘起

+ 目前是想分为3个阶段，各阶段暂定1个月（整理）吧，因为之前有零星看过了：
  + 阶段1是**网卡驱动**，
  + 阶段2是**L3层相关**，
  + 阶段3是**socket层和L4**
+ 这部分是来自《深入理解linux网络技术内幕》的Part5-7，也就是从chap14-chap36
+ 目标是**2024-09**把这部分啃完吧，**建立了知识骨架**，代码实现细节先不求（**主要是知识点多**）
  + chap1-13，**相关的函数细节**要把代码注释一下
+ 自己整理的[链接](https://gitee.com/fewolflion/BookNote/blob/master/00tech_output_ppt/20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%A7%E7%B1%BB/11tcp-ip-stack%E5%86%85%E6%A0%B8/02%E4%B8%89%E5%B1%82%E5%8D%8F%E8%AE%AE-%E6%A1%A5%E6%8E%A5%20%E8%B7%AF%E7%94%B1%20%E9%82%BB%E5%B1%85%20IP.pdf)是这个
  + 用ppt写的，转成的pdf
  + md写的吧，*自己搞图和标色，不太方便*

## 内容

+ outline呢，*差不多，想用自己了解到的给串一下*
+ 简单的说，**IPv4的大蓝图**用到了**路由缓存dst**，（寻路），**邻居子系统**（L3到L2地址转换），**网桥**（*这个不绝对，发给网桥设备，还是真实的网卡设备，L3应该不用感知*）

### 0、outline

+ **每一层都有一个核心问题**，这一层的功能是啥？有什么用？

#### part4、桥接

+ 一、输入，`netif_receive_skb()`，**怎么区分，真实网卡设备，和虚拟设备**【真实设备的就是drivers下面的网卡驱动，虚拟设备，就是net/bridge下面的】*不完全绝对啊*
+ 二、输出，跟**e100.c一样都要调用`dev_queue_xmit()`输出一样**，真正绑定的实例还是**`net_device_ops`实例**中的`ndo_xmit`对应的真实函数，*这有点类似于虚拟函数*
+ 三、**中间处理逻辑**，核心是**大蓝图**，以及逻辑基本都在`net/bridge`目录
+ 【新的问题：**桥接**在整个协议栈的位置】
  + *具体不记得了，应该也是有个大蓝图的*
+ 怎么在用户态创建网桥，用什么命令？

#### part5、IPv4

+ **记住图18-1，对应的大蓝图**

+ 一、输出，先记一个吧，**`ip_queue_xmit()`**，还有`ip_push_pending_frames()`，中间会经过**`dst->output()`**，*省略一些细节*，到达`dev_queue_xmit()`
+ 二、输入，网卡驱动对应的**协议处理函数`ip_rcv()`**，还是通过`dst->input()`进行**转发`ip_forward()`**和**传输到L4层，`ip_local_deliver()`**
+ 三、中间处理，*目前知道的，就是*，（**分段和重组**），至少*找路由，找网络邻居*细节先不管

#### part6、邻居子系统

+ 这部分逻辑比较简单，**就是封装了邻居这层**（之前是ARP和ND），*现在为了弱化ipv4和ipv6的差异*
+ **L3协议与邻居协议间的通用接口**，就是`neigh->ops`

#### part7、路由

+ *不是完全明白*，现在**路由hash**代码中跟书上都不太一样了
+ 目前主要看的是**路由缓存**章节，正好是`dst->input()`这样的
+ 搞清楚了自己的疑问
  + 看路由的时候，想到的是**路由协议**，之前想的是rip，ospf这些对应的rfc文档在**内核中的实现**，后面觉得不对，**它们是用`ip route`这样的命令去配置的**，然后才知道有**路由守护进程**专门干这事

## 最后

### 履历

+ 0.1版，2024-09月第1周整理的，目前已经把这4个部分过了一遍了，**Part7路由中的一些，实现的基础知识**有点欠缺，*暂未找到合适的材料*，2024-09-05，用了一个cubi