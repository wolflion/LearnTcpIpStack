## 缘起

### 不断优化后的方法

+ 先分大块，再把各个小节串起来

### 过程中一直会有的疑惑

+ 学这个有什么用，（**尤其最开始的时候，不见成效的会这么想**），但当自己**渐入佳境**的时候，**知识是一方面了，更重要的是打磨了一套方法论，以及建立了一种干过这活的经验**

### 在这个过程中想学到（有啥问题要解决）

+ 问题1，对协议栈知识匮乏，**内核之前零星看了，根本没有形成知识体系**
+ 问题2，ppt汇报也好，还是自己平时也好，**文档写得没有条理性**（自己觉得还是有逻辑的啊），通过不断写多个版本，**打磨一下知识的体系**

### 代码着手示例

+ 1、网卡驱动相关，loopback.c，e100.c【这里面有NAPI】
+ 2、借助于用户态和内核态的接口，*具体我还没想好*

## 二、内容

### 0、outline

#### part1、基础（section2）

+ 1、关键数据结构（sk_buff，net_device，sock）
+ 2、用户空间与内核空间的接口（ioctl，sysctl，netlink，proc目录）
  + ioctl应该知道
  + **路由守护进程**与内核通信用的是,netlink

#### part2、初始化（section5）

+ 3、网络设备初始化（net_dev_init）
+ 4、PCI和网络接口卡（pci_register_driver）
+ 5、设备注册和初始化（net_device结构体赋值，register_netdev，register_netdevice）
+ 附1、通知链（*先知道怎么用*）
+ 附2、组件初始化的内核基础架构（**XXX_initcall宏的具体实现**）

#### part3、数据收发（section5）

+ 附：前置知识（中断，e100_intr）
+ 6、接收帧（e100_poll，net_rx_action）
+ 7、帧的传输（dev_queue_xmit）
+ 8、协议处理函数（不同的packet_type绑定不同的处理函数）
+ 其它、中断性的一般性参考（*暂不太明白*）

#### part4

+ 9、流量控制（Qdisc）

### 2.3、网络设备初始化

#### 内核的初始化（init/main.c）

+ *暂不是重点*

#### 初始化选项和模块选项

+ `module_init(e100_init_module)`，*想了解细节，可在 附2 里面好好看看*
+ `subsys_initcall(net_dev_init);`

#### 设备处理层初始化（dev.c中的net_dev_init）

+ *有一部分是内核负责的，有一部分是驱动负责的*，再完善下

### 2.4、PCI和网络接口卡

#### PCI网卡设备驱动的注册（pci_register_driver）

+ pci设备（硬件设备，mac唯一），pci_device_id结构体（**mod_device.h**）决定，这个文件里**记录都是系统中的设备**，
+ pci.h
  + `pci_dev`，定义了一个**pci设备**
  + pci设备里面有个**驱动**，就是`struct pci_driver`【**e100中的实例就是e100_driver**】
  + pci_driver结构体里，**需要讲一下基本的驱动结构**，那就是`struct drvier_device`
+ 以e100.c文件为例，需要**创建pci_driver的实例e100_driver**， `e100_init_module`进行初始化，再调用pci_register_driver【pci与驱动关联】，实现是在`pci_driver.c`中，暂没太关注，
+ 一切就绪后，*自动触发*【网上查的】`e100_probe`

#### PCI网卡驱动程序注册范例

+ `static const struct pci_device_id e100_id_table[]`，*这个之前没太关注，这个有啥用呢*

#### 非书上的内容

##### pci插槽的网卡

+ 网上搜一下“PCI 百兆网卡”即可，有个大概的概念
+ 有以下几个部分组成
  + PCI接口，*为了与计算机通信*
  + 网卡控制器，**网卡芯片组**里，用于数据的收发
  + PHY芯片，**数字信号转换为模拟信号**，以太网的物理信号
  + RJ45接口，*连网线*
  + 存储器，*存储固件信息，收包器*
  + 指示灯，*网络工作状态*

### 2.5、设备注册和初始化

+ **`e100_driver`实例中的** e100_probe/e100_remove

#### 设备注册（register_netdevice）

#### e100_probe

+ 定义`struct net_device *netdev`的实例是由`alloc_etherdev()`创建，**分配空间**
+ 创建OK了要去**注册**，`register_netdev()` 【dev.c中实现】，*也能理解，属于网络设备了*

#### 设备除名（unregister_netdevice）

#### e100_remove

*未看*

#### 开启和关闭网络设备

#### 用户态命令（ifconfig，ethtool）

+ *最终整定都是调用ioctl*，当然ioctl在内核侧也分2种情况

### 2.9、接收帧（e100_poll，net_rx_action）

+ *这部分不难*，【**把中断，软中断看完**，就有感觉了】

### 2.10、帧的传输（dev_queue_xmit，net_tx_action）

#### 调度队列与流量控制

+ *未串起来*，先假设啥也不需要

#### dev_queue_xmit函数

+ 核心是**调用具体硬件的驱动程序传输函数`hard_start_xmit()`，对于e100的话就是`e100_xmit_frame()`**

#### 处理NET_TX_SOFTIRQ：net_tx_action

+ `raise_softirq_irqoff(NET_TX_SOFTIRQ)`触发了这个软中断，就会调用`net_tx_action()`，主要干2件事
  + 1、把帧传出去，*我再想一下用什么函数*
  + 2、当收到消息说缓冲区可回收了，把缓冲区sk_buff给回收回来

### 2.11、协议处理函数（不同的packet_type绑定不同的处理函数）

#### 协议处理函数的注册（把packet_type实例放进来，通过dev_add_pack）

+ 在`ip_init()`中调用`dev_add_pack(&ip_packet_type)`，把packet_type实例ip_packet_type注册进来

### 流量控制（Qdisc）

+ *输入和输出，其实都有流量控制*（但流量控制 内核代码还是蛮多的，我就写一下【书上已有的结构，目前代码中怎么用起来的】）

#### 流量控制的三要素（排队规则，类，过滤器）

+ `sch_generic.h`中定义的结构体，`struct Qdisc{},struct XXX_class{}, struct tcf_proto{},`

#### 默认的排队规则

+ *不太清楚呢*

#### 用tc命令进行流控

+ *之前还用过呢，后来再补充上去*

## 最后

+ 希望整到1.0的时候，可以出一个能看的版本，也把书中的前8章，真的给搞懂了

### 履历

+ 0.1版，大概是懂了（2.1-2.3），2.4启停嘛，毕竟也操作过，有点概念，但内核具体的没看过，2.5收发完全是浆糊，2024-08-09整了一版，时长1个cubi
+ 0.2版，重新更正了参考教材，把**路由**初看了一下（之前没看过），把接收用到的**中断**知识初步理解了下

### 参考书

+ 《深入理解Linux网络技术内幕》1-13，简称ULNI
  + *对于小白不算友好（至少对我），但入了门看它，就能渐入佳境了*，最开始看的时候呢，**容易陷入细节，看不懂，当有了大的框架，再看它，就能把各个点串一下了**（当然，虽然版本老了，自己借助AI和代码，再猜猜也能明白），*协议栈，netfilter，一些组件缺失没讲*
+ 《Linux内核源码剖析-TCP/IP实现》1-9
  + *把一个函数讲得细，但关联性方面，比较差，内容也更全面些*
+ 《深入Linux内核架构》，6，12，14，简称PLKA，
  + **需要的时候再看它**，比如（数据包的接收需要了解**中断**方面的知识，就把14章看了看）
+ 《Linux设备驱动程序3》，17，简称LDD3
  + *想着主线是（字符设备，块设备，网络设备及其它），其它的算是基础吧*