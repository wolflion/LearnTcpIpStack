## 缘起

### 不断优化后的方法

+ 先分大块，再把各个小节串起来

### 过程中一直会有的疑惑

+ 学这个有什么用，（**尤其最开始的时候，不见成效的会这么想**），但当自己**渐入佳境**的时候，**知识是一方面了，更重要的是打磨了一套方法论，以及建立了一种干过这活的经验**

### 在这个过程中想学到（有啥问题要解决）

+ 问题1，对协议栈知识匮乏，**内核之前零星看了，根本没有形成知识体系**
+ 问题2，ppt汇报也好，还是自己平时也好，**文档写得没有条理性**（自己觉得还是有逻辑的啊），通过不断写多个版本，**打磨一下知识的体系**

### 代码着手示例

+ 1、网卡驱动相关，loopback.c，e100.c【这里面有NAPI】
+ 2、借助于用户态和内核态的接口，*具体我还没想好*

## 二、内容

### 用dev.c和e100.c进行知识大串联

+ dev.c可以理解为**设备驱动**的接口，e100.c代表具体的网卡驱动
+ 1、首先**初始化**，整个模块的初始化，**内核提供了哪些初始化方法**，利用它们进行**网络设备的初始化**
+ 2、初始化后就是**设备注册**，主要目的是啥呢，**让内核能操作设备**
+ 3、**操作设备**，比如打开和关闭，**比如可以通过`ioctl()`与内核交互**
+ 4、网卡启用了就得工作**接收和传输数据**，*记住接口蓝图*，向下是输出是`dev_queue_xmit`
+ 5、向上的话**要交给L3处理**，具体交给谁呢，就得根据**场景中的`packet_type`实例了**

#### 首先进行初始化

+ e100.c中，`module_init()`和`__init()`对应书中的 `chap7组件初始化`，**与内核交互**，*代码实现中，就能看到dev.c和e100.c的初始化顺序问题*
+ **抽象网络设备初始化**，dev.c中的`net_dev_init()`，**从执行顺序来看，确实也比e100.c的初始化更早点**，对应`chap5网络设备初始化`
+ **具体pci网卡设备注册**，e100.c中`pci_register_driver(&e100_driver)`，e100_driver就是`pci_driver`结构体的实例，对应`chap6pci层和网络接口卡`，**这里算是注册pci设备**
+ **注册网络设备**，dev.c中的`register_netdev()`和`register_netdevice()`有啥区别？，前者的实现里，也就是调用了后者，*所以可以不用记前面的了，书上都没讲*，对应书`chap8设备注册与初始化`
  + *前是2.2版本之前，后面是2.2之后用于替换前面的*
+ **打开和关闭网卡**，dev.c中的`dev_open()`，但**如何去调用e100.c中的`e100_up()`打开真正的网卡**要自己能串起来，对应书`chap8设备注册与初始化`

#### 准备就绪，收发数据

+ 硬件（网卡）收到数据后，向CPU发起**中断**，对应`chap9中断和网络驱动程序`，*这个地方细节就不提了*，可以去记一下e100.c中的`request_irq(nic->pdev->irq, e100_intr, IRQF_SHARED,nic->netdev->name, nic->netdev)`，**主要是request_irq，就是请求中断**，对应`chap12中断事件`，*看得不多*
+ 接收数据，**现在是NAPI机制了**，用了**下半部**思想，用到了**软中断**，e100.c触发中断后，需要下半部去处理数据了，`__napi_schedule(&nic->napi)`，对应`chap10帧的接收`
+ **传输数据（就是output）**，对于dev.c的这种通用接口就是`dev_queue_xmit()`，对于具体的网卡驱动而言，e100.c中就是`e100_xmit_frame()`，

#### 继续向上交给L3处理，ip_packet_type

+ **对于ipv4而言，目录中的`/net/ipv4/af_inet.c`中的`inet_init()`就处理好了所有流程**，就不是在驱动里面做了，同样`static struct packet_type ip_packet_type`也就定义好了，对应书中的`chap13协议处理函数`，**这样就进入了`ip_rcv`**
  + 以`static struct packet_type`为关键字，找到了`net/can/af_can.c`中定义的实例`can_packet()`，从而进行`can_rcv()`
  + **也有比较简单的场景**，就直接在驱动里的，*可以理解为不需要跟上层交互，自己就解决了？*，`drivers/net/wan/hdlc.c`，定义了`hdlc_packet_type`，也关联了处理函数`hdlc_rcv()`，不过就在本文件内处理掉了

### 0、outline

#### part1、基础（section2）

+ 1、关键数据结构（sk_buff，net_device，sock）
+ 2、用户空间与内核空间的接口（ioctl，sysctl，netlink，proc目录）
  + ioctl应该知道
  + **路由守护进程**与内核通信用的是,netlink

#### part2、初始化（section5）

+ 3、网络设备初始化（net_dev_init）
+ 4、PCI和网络接口卡（pci_register_driver）
+ 5、设备注册和初始化（net_device结构体赋值，register_netdev，register_netdevice）
+ 附1、通知链（*先知道怎么用*）
+ 附2、组件初始化的内核基础架构（**XXX_initcall宏的具体实现**）

#### part3、数据收发（section5）

+ 附：前置知识（中断，e100_intr）
+ 6、接收帧（e100_poll，net_rx_action）
+ 7、帧的传输（dev_queue_xmit）
+ 8、协议处理函数（不同的packet_type绑定不同的处理函数）
+ 其它、中断性的一般性参考（*暂不太明白*）

#### part4

+ 9、流量控制（Qdisc）

### 2.3、网络设备初始化

#### 内核的初始化（init/main.c）

+ *暂不是重点*

#### 初始化选项和模块选项

+ `module_init(e100_init_module)`，*想了解细节，可在 附2 里面好好看看*
+ `subsys_initcall(net_dev_init);`

#### 设备处理层初始化（dev.c中的net_dev_init）

+ *有一部分是内核负责的，有一部分是驱动负责的*，再完善下

### 2.4、PCI和网络接口卡

#### PCI网卡设备驱动的注册（pci_register_driver）

+ pci设备（硬件设备，mac唯一），pci_device_id结构体（**mod_device.h**）决定，这个文件里**记录都是系统中的设备**，
+ pci.h
  + `pci_dev`，定义了一个**pci设备**
  + pci设备里面有个**驱动**，就是`struct pci_driver`【**e100中的实例就是e100_driver**】
  + pci_driver结构体里，**需要讲一下基本的驱动结构**，那就是`struct drvier_device`
+ 以e100.c文件为例，需要**创建pci_driver的实例e100_driver**， `e100_init_module`进行初始化，再调用pci_register_driver【pci与驱动关联】，实现是在`pci_driver.c`中，暂没太关注，
+ 一切就绪后，*自动触发*【网上查的】`e100_probe`

#### PCI网卡驱动程序注册范例

+ `static const struct pci_device_id e100_id_table[]`，*这个之前没太关注，这个有啥用呢*

#### 非书上的内容

##### pci插槽的网卡

+ 网上搜一下“PCI 百兆网卡”即可，有个大概的概念
+ 有以下几个部分组成
  + PCI接口，*为了与计算机通信*
  + 网卡控制器，**网卡芯片组**里，用于数据的收发
  + PHY芯片，**数字信号转换为模拟信号**，以太网的物理信号
  + RJ45接口，*连网线*
  + 存储器，*存储固件信息，收包器*
  + 指示灯，*网络工作状态*

### 2.5、设备注册和初始化

+ **`e100_driver`实例中的** e100_probe/e100_remove

#### 设备注册（register_netdevice）

#### e100_probe

+ 定义`struct net_device *netdev`的实例是由`alloc_etherdev()`创建，**分配空间**
+ 创建OK了要去**注册**，`register_netdev()` 【dev.c中实现】，*也能理解，属于网络设备了*

#### 设备除名（unregister_netdevice）

#### e100_remove

*未看*

#### 开启和关闭网络设备

#### 用户态命令（ifconfig，ethtool）

+ *最终整定都是调用ioctl*，当然ioctl在内核侧也分2种情况

### 2.9、接收帧（e100_poll，net_rx_action）

+ *这部分不难*，【**把中断，软中断看完**，就有感觉了】

### 2.10、帧的传输（dev_queue_xmit，net_tx_action）

#### 调度队列与流量控制

+ *未串起来*，先假设啥也不需要

#### dev_queue_xmit函数

+ 核心是**调用具体硬件的驱动程序传输函数`hard_start_xmit()`，对于e100的话就是`e100_xmit_frame()`**

#### 处理NET_TX_SOFTIRQ：net_tx_action

+ `raise_softirq_irqoff(NET_TX_SOFTIRQ)`触发了这个软中断，就会调用`net_tx_action()`，主要干2件事
  + 1、把帧传出去，*我再想一下用什么函数*
  + 2、当收到消息说缓冲区可回收了，把缓冲区sk_buff给回收回来

### 2.11、协议处理函数（不同的packet_type绑定不同的处理函数）

#### 协议处理函数的注册（把packet_type实例放进来，通过dev_add_pack）

+ 在`ip_init()`中调用`dev_add_pack(&ip_packet_type)`，把packet_type实例ip_packet_type注册进来

### 流量控制（Qdisc）

+ *输入和输出，其实都有流量控制*（但流量控制 内核代码还是蛮多的，我就写一下【书上已有的结构，目前代码中怎么用起来的】）

#### 流量控制的三要素（排队规则，类，过滤器）

+ `sch_generic.h`中定义的结构体，`struct Qdisc{},struct XXX_class{}, struct tcf_proto{},`

#### 默认的排队规则

+ *不太清楚呢*

#### 用tc命令进行流控

+ *之前还用过呢，后来再补充上去*

## 最后

+ 希望整到1.0的时候，可以出一个能看的版本，也把书中的前8章，真的给搞懂了

### 履历

+ 0.1版，大概是懂了（2.1-2.3），2.4启停嘛，毕竟也操作过，有点概念，但内核具体的没看过，2.5收发完全是浆糊，2024-08-09整了一版，时长1个cubi
+ 0.2版，重新更正了参考教材，把**路由**初看了一下（之前没看过），把接收用到的**中断**知识初步理解了下
+ 0.3版，把核心的过程给提一下，**但具体的函数实现**还没看  【这2天主要在看ipv4和邻居子系统，没怎么看这部分了，本周补上】

### 参考书

+ 《深入理解Linux网络技术内幕》1-13，简称ULNI
  + *对于小白不算友好（至少对我），但入了门看它，就能渐入佳境了*，最开始看的时候呢，**容易陷入细节，看不懂，当有了大的框架，再看它，就能把各个点串一下了**（当然，虽然版本老了，自己借助AI和代码，再猜猜也能明白），*协议栈，netfilter，一些组件缺失没讲*
+ 《Linux内核源码剖析-TCP/IP实现》1-9
  + *把一个函数讲得细，但关联性方面，比较差，内容也更全面些*
+ 《深入Linux内核架构》，6，12，14，简称PLKA，
  + **需要的时候再看它**，比如（数据包的接收需要了解**中断**方面的知识，就把14章看了看）
+ 《Linux设备驱动程序3》，17，简称LDD3
  + *想着主线是（字符设备，块设备，网络设备及其它），其它的算是基础吧*